<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>React进阶实践指南5-理解lifeCycle | 飞向月球的猫</title><meta name="keywords" content="React进阶实践指南"><meta name="author" content="飞向月球的猫"><meta name="copyright" content="飞向月球的猫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="React进阶实践指南5-理解lifeCycle"><meta name="application-name" content="React进阶实践指南5-理解lifeCycle"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="React进阶实践指南5-理解lifeCycle"><meta property="og:url" content="http://kaiyiya.github.io/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/index.html"><meta property="og:site_name" content="飞向月球的猫"><meta property="og:description" content="React进阶实践指南-理解lifeCycle"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2025/06/19/685352676eddc.jpg"><meta property="article:author" content="飞向月球的猫"><meta property="article:tag" content="深度学习 算法 全栈开发 移动端开发 js python java go c++ c"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2025/06/19/685352676eddc.jpg"><meta name="description" content="React进阶实践指南-理解lifeCycle"><link rel="shortcut icon" href="/img/icon_man.png"><link rel="canonical" href="http://kaiyiya.github.io/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机"]},
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":800,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 飞向月球的猫","link":"链接: ","source":"来源: 飞向月球的猫","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '飞向月球的猫',
  title: 'React进阶实践指南5-理解lifeCycle',
  postAI: '',
  pageFillDescription: '一 前言, 二 类组件生命周期介绍, React 类组件生命周期执行过程探秘, 初始化阶段, 更新阶段, 销毁阶段, React 各阶段生命周期能做些什么, 1 constructor, 2 getDerivedStateFromProps, 3 componentWillMount 和 UNSAFE_componentWillMount, 4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps, 5 componentWillUpdate 和 UNSAFE_componentWillUpdate, 6 render, 7 getSnapshotBeforeUpdate, 8 componentDidUpdate, 9 componentDidMount, 10 shouldComponentUpdate, 11 componentWillUnmount, 实例, 生命周期调用顺序说明：, 现代React开发建议：, 3 函数组件生命周期替代方案, 1 useEffect 和 useLayoutEffect, 2 useInsertionEffect, 3 componentDidMount 替代方案, 4 componentWillUnmount 替代方案, 5 componentWillReceiveProps 代替方案, 6 componentDidUpdate 替代方案, 7 完整代码和效果, 四 实践-实现一个ScrollView组件一前言在本章节中主要讲的生命周期类组件为开发者提供了一些生命周期钩子函数能让开发者在执行的重要阶段在钩子函数里做一些该做的事自从问世以来函数组件也能优雅地使用弥补函数组件没有生命周期的缺陷希望通过本章节让你一次性搞定生命周期的流程和能弄清楚在各个生命周期做些什么第二点就是加深对中和的使用二类组件生命周期介绍在讲生命周期之前有必要先来简单聊聊两个重要阶段阶段和阶段在调和阶段会深度遍历树目的就是发现不同不同的地方就是接下来需要更新的地方对于变化的组件就会执行函数在一次调和过程完毕之后就到了阶段阶段会创建修改真实的节点如果在一次调和的过程中发现了一个类组件的情况就会按照类组件的逻辑来处理对于类组件的处理逻辑首先判断类组件是否已经被创建过首先来看看源码里怎么写的处理类组件的主要功能方法是指向类组件实例的指针为组件实例如果组件实例不存在证明该类组件没有被挂载过那么会走初始化流程组件实例将在这个方法中被初始化挂载组件流程标识用来证明组件是否需要更新更新组件流程执行函数得到子节点继续调和子节点几个重要概念类组件对应实例树当前正在调和的树一次更新中会自上而下深度遍历子代如果遍历到一个会把当前指向树在初始化更新中在第一次调和之后会将树赋值给树来用和来确保一次更新中快速构建并且状态不丢失就是项目中的组件作为组件在一次更新中新的作为下一次渲染的过期时间在组件实例上可以通过属性来访问组件对应的对象在对象上可以通过来访问当前对应的组件实例两者的关系如下图所示类组件生命周期执行过程探秘的大部分生命周期的执行都在和这两个方法中执行所以为了让大家深入学习生命周期的执行过程我觉得有必要去揭秘这两个函数充当了什么角色我把流程简化成初始化渲染和更新两个方向为了让大家更理解生命周期的执行流程我这里分为组件初始化组件更新组件销毁三大阶段分析初始化阶段执行在阶段首先执行的函数用来实例化组件在组件章节已经介绍了这个函数组件中就是在这里执行的在实例化组件之后会调用组件初始化接下来看一下做了些什么我只写了和生命周期息息相关的代码就是我们写的类组件获取类组件的静态方法这个时候执行生命周期得到将合并的合并将赋值给我们实例上就是我们在组件中获取的当和不存在的时候执行执行在初始化阶段是第二个执行的生命周期值得注意的是它是从类上直接绑定的静态方法传入返回值将和之前的合并作为新的传递给组件实例使用执行如果存在和就不会执行生命周期函数执行到此为止函数完成但是上面函数在执行完后执行了渲染函数形成了接下来调用方法深度调和执行细心的同学可能发现生命周期还没有出现那么是如何执行的呢上文中简单介绍了和两个阶段上述提及的几生命周期都是在阶段执行的一旦调和完所有的节点就会到阶段在组件初始化阶段会调用生命周期在第一节讲了不同类型如果是类组件类型类实例类组件第一次调和渲染类组件更新从上面可以直观看到执行时机和执行时机是相同的只不过一个是针对初始化一个是针对组件再更新到此初始化阶段生命周期执行完毕执行顺序接下来分析一下一次组件更新中会有哪些生命周期执行呢更新阶段接下来一次类组件的更新阶段到底会执行那些生命周期函数呢回到了最开始函数了当发现不为的情况时说明该类组件被挂载过那么直接按照更新逻辑来处理类组件实例判断是否具有生命周期浅比较不相等执行生命周期执行生命周期逻辑和类似合并执行生命周期返回值决定是否执行调和子节点执行生命周期执行生命周期首先判断生命周期是否存在如果不存在就执行生命周期传入该生命周期两个参数分别是和执行生命周期接下来执行生命周期返回的值用于合并生成新的执行生命周期接下来执行生命周期传入新的新的和新的返回值决定是否继续执行函数调和子节点这里应该注意一个问题的返回值可以作为新的传递给执行生命周期接下来执行生命周期方法到此执行完毕了执行函数接下来会执行函数得到最新的元素然后继续调和子节点执行执行生命周期返回值将作为传递给生命周期的执行也是在阶段阶段细分为修改前修改修改后三个阶段发生在阶段生命周期的返回值将作为第三个参数传递给执行接下来执行生命周期此时已经修改完成可以操作修改之后的到此为止更新阶段的生命周期执行完毕更新阶段对应的生命周期的执行顺序改变销毁阶段执行生命周期销毁阶段就比较简单了在一次调和更新中如果发现元素被移除就会打对应的标签然后在阶段就会调用生命周期接下来统一卸载组件以及元素三个阶段生命周期无状态组件总览图各阶段生命周期能做些什么上面部分详细的介绍了各生命周期的执行时机和执行顺序接下来分别介绍一下各个能做些什么在不同时期抛出不同的生命周期钩子也就意味这这些生命周期钩子的使命上面讲过在类组件创建实例时调用而且初始化的时候执行一次所以可以在做一些初始化的工作执行别忘了传递才能在接下来的上下文中获取到可以用来初始化比如可以用来获取路由中的绑定绑定防抖函数防抖毫秒劫持修改类组件上的一些生命周期点击事件表单输入作用初始化比如可以用来截取路由中的参数赋值给对类组件的事件做一些处理比如绑定节流防抖等对类组件进行一些必要生命周期的劫持渲染劫持这个功能更适合反向继承的在环节会详细讲解反向继承这种模式两个参数父组件新传递的传入待合并的方法作为类的静态属性方法执行内部是访问不到的它更趋向于纯函数从源码中就能够体会到对该生命周期定义为取缔和如果把英文分解翻译得到派生的从中正如它的名字一样这个生命周期用于在初始化和更新阶段接受父组件的数据可以对进行格式化过滤等操作返回值将作为新的合并到中供给视图渲染层消费从源码中可以看到只要组件更新就会执行不管是改变还是或是苹果香蕉葡萄接受变化返回值将作为新的用于渲染或传递给菠菜西红柿土豆作用代替和组件初始化或者更新时将映射到返回值与合并完可以作为第二个参数可以判断是否渲染组件请不要把和强行关联到一起两者没有必然联系和在三个生命周期加上了不安全的标识符变成了如下形式在目前最新的版本也没有废弃这三个生命周期可能不久之后更高级的版本会被废除吧首先先来看一下为什么要加首先根据源码大家有没有发现一个问题就是这三个生命周期都是在之前执行的对于执行函数有着像等条件制约但是对于执行在之前生命周期没有限制存在一定隐匿风险如果执行多次开发者滥用这几个生命周期可能导致生命周期内的上下文多次被执行的作用还是做一些初始化操作但是不建议在这个生命周期写毕竟未来可能完全取缔它和函数的执行是在更新组件阶段该生命周期执行驱动是因为父组件更新带来的修改但是只要父组件触发函数调用方法那么就会被重新创建生命周期就会执行了这就解释了即使没变该生命周期也会执行可以用来干什么我把上面例子修改一下父组件执行监听父组件执行异步控制改变派生出来的的修改苹果香蕉葡萄苹果香蕉葡萄可以用来监听父组件是否执行可以用来接受改变组件可以根据改变来决定是否更新因为可以访问到所以可以在异步成功回调接口请求数据改变这个是不能实现的但是笔者不建议用这种方式改变再触发异步请求数据渲染这样首先在没做优化前提下会带来两次子组件的更新第一次改变第二次改变异步改变其次该生命周期的不安全性再者需要在该生命周期内部设置大量的条件判断语句通过判断到底改变与否所以完全可以换一种思路那就是状态提升把数据层完全托管父组件子组件没有副作用只负责渲染父组件传递的即可问与答问当不变的前提下组件能否阻止执行答案是否定的生命周期的执行和纯组件没有关系纯组件是在执行之后浅比较是否发生变化所以下不会阻止该生命周期的执行和可以意味着在更新之前此时的还没有更新在这里可以做一些获取的操作就比如说在一次更新中保存之前的信息记录上一次位置但是已经出了新的生命周期来代替获取元素节点位置作用获取组件更新之前的状态比如元素位置等还记得在第一节主要讲了之后会成什么样子所谓函数就是的各个元素被创建成对象的形式一次的过程就是创建元素的过程那么可以在里面做一些创建元素克隆元素遍历的操作两个参数更新前的更新前的把用英文解释一下中文翻译为获取更新前的快照可以进一步理解为获取更新前的状态见名知意上面说过该生命周期是在阶段的修改前此时还没有更新但是在接下来的阶段会被替换成真实此时是获取信息的最佳时期将返回一个值作为一个快照传递给作为第三个参数注意如果没有返回值会给予警告如果没有也会给予警告传递更新前的元素位置获取元素绘制之前的位置当然这个快照不限于的信息也可以是根据计算出来产物作用这个生命周期意义就是配合一起使用计算形成一个传递给保存一次更新前的信息获取元素最新位置信息三个参数更新之前的更新之前的为返回的快照可以是更新前的信息作用生命周期执行此时已经更新可以直接获取最新状态这个函数里面如果想要使用一定要加以限制否则会引起无限循环接受保存的快照信息生命周期执行时机和一样一个是在初始化一个是组件更新此时已经创建完既然已经创建挂载就可以做一些基于操作事件监听器事件监听数据请求作用可以做一些关于操作比如基于的事件监听器对于初始化向服务器请求数据渲染视图这个生命周期也是蛮合适的三个参数第一个参数新的第二个参数新的第三个参数新的中属性发生变化渲染组件中属性发生变化渲染组件否则组件不渲染这个生命周期一般用于性能优化返回值决定是否重新渲染的类组件需要重点关注的是第二个参数如果有生命周期它的返回值将合并到供使用是组件销毁阶段唯一执行的生命周期主要做一些收尾工作比如清除一些可能造成内存泄漏的定时器延时器或者是一些事件监听器清除延时器卸载事件监听器作用清除延时器定时器一些基于的操作比如事件监听器实例构造函数初始化和绑定方法静态方法从派生在初始挂载和更新时都会调用通常用于变化时更新即将过时的挂载前方法不推荐使用即将过时的接收方法不推荐使用即将过时的更新前方法不推荐使用渲染方法必须的生命周期演示计数父组件传递的初始值增加计数卸载组件获取更新前快照在更新前调用返回的值会传递给更新前快照数据更新完成方法挂载完成方法适合网络请求性能优化方法决定是否重新渲染只有当计数变化时才更新卸载前清理方法清除定时器取消请求自定义方法生命周期演示卸载组件挂载组件更改强制重新创建组件生命周期调用顺序说明组件挂载阶段初始化和绑定方法从派生即将废弃的挂载前方法渲染挂载后执行适合网络请求组件更新阶段或变化即将废弃的接收方法从新派生决定是否重新渲染即将废弃的更新前方法重新渲染获取更新前的信息更新后执行组件卸载阶段卸载前清理清除定时器取消请求注意事项方法标记为的方法已在中弃用建议避免使用是静态方法不能访问必须与配合使用通过返回控制更新用于性能优化属性父组件中使用强制重置子组件状态现代开发建议使用函数组件替代类组件避免使用已弃用的生命周期方法状态管理优先使用副作用处理使用性能优化使用和函数组件生命周期替代方案也提供了用于弥补函数组件没有生命周期的缺陷其原理主要是运用了里面的和和第一个参数返回的作为下一次执行之前调用用于清除上一次产生的副作用第二个参数作为依赖项是一个数组可以有多个依赖项依赖项改变执行上一次返回的和执行新的第一个参数对于执行处理逻辑是采用异步调用对于每一个的会向回调函数一样放入任务队列等到主线程任务完成更新执行完成视图绘制完毕才执行所以回调函数不会阻塞浏览器绘制视图和不同的地方是采用了同步执行那么和有什么区别呢首先是在更新之后浏览器绘制之前这样可以方便修改获取信息这样浏览器只会绘制一次如果修改布局放在那执行是在浏览器绘制视图之后接下来又改就可能会导致浏览器再次回流和重绘而且由于两次绘制视图上可能会造成闪现突兀的效果中代码执行会阻塞浏览器绘制一句话概括如何选择和修改改变布局就用其他情况就用问与答问回调函数和执行时机有什么区别答对执行栈来看是异步执行的而是同步执行的代码不会阻塞浏览器绘制在时机上和更类似是在新添加的它的用法和和一样那么这个用于什么呢在介绍用途之前先看一下的执行时机执行执行执行打印执行执行执行可以看到的执行时机要比提前执行的时候已经更新了但是在的执行的时候还没有更新本质上主要是解决在渲染中注入样式的性能问题这个主要是应用于这个场景在其他场景下不期望用这个的注入会引发哪些问题呢首先看部分的实现原理拿为例子通过你可以使用的标签模板字符串语法为需要的定义一系列属性当该组件的代码被解析执行的时候会动态生成一个选择器并把对应的样式通过标签的形式插入到标签里面动态生成的选择器会有一小段哈希值来保证全局唯一性来避免样式发生冲突这种模式下本质上是动态生成标签明白了原理之后再来看一下如果在使用会造成哪里问题呢首先执行的时机已经更新完成布局也已经确定了剩下的就是交给浏览器绘制就行了如果在动态生成标签那么会再次影响布局导致浏览器再次重回和重排这个是时候的作用就出现了的执行在更新前所以此时使用避免了浏览器出现再次重回和重排的可能解决了性能上的问题接下来我们模拟一下在使用流程动态创建标签插入到中效果此时的字体颜色和字体大小已经更改上述详细的介绍了和接下来拿做参考详细介绍一下函数组件怎么实现生命周期的替代方案的替代方案请求数据事件监听操纵切记这里要记住这样当前没有任何依赖项也就只有初始化执行一次替代方案请求数据事件监听操纵增加定时器延时器解除事件监听器清除定时器延时器切记在的前提下第一个函数的返回函数可以作为使用代替方案说代替着实有点牵强首先因为二者的执行阶段根本不同一个是在阶段一个是在阶段其次会初始化执行一次但是只有组件更新变化的时候才会执行变化此时依赖项就是变化执行此时的钩子中变化当前仅当中变化执行当前钩子还可以针对的某一个属性进行追踪此时的依赖项为的追踪属性如上述代码只有中变化执行替代方案和在执行时期虽然有点差别是异步执行是同步执行但都是在阶段但是向上面所说会默认执行一次而只有在组件更新完成后执行组件更新完成没有依赖项注意此时没有第二个参数没有第二个参数那么每一次执行函数组件都会执行该完整代码和效果请求数据事件监听操纵增加定时器延时器组件挂载完成解除事件监听器清除组件销毁切记变化组件更新完成改变改变卸载组件四实践实现一个组件接下来为了让大家加深对生命周期各阶段的理解我写了一个编写一个类似小程序或是中的组件主要用于长列表渲染滑动底部请求渲染列表组件本身功能不重要实现细节也不需要太纠结本节讲的是生命周期明白生命周期的各个阶段应该做些什么才重要使用完全是单元项的渲染记录列表数据请求数据没有数据了滚动到底部触发已经到底部初始化请求数据渲染的单元组件自定义事件控制滚动条滚动判断滚动条是否到底部到达容器底部位置生命周期初始化防抖处理接收合并到性能优化只有列表数据变化渲染列表获取更新前容器高度获取更新后容器高度容器高度变化绑定事件监听器监听事件解绑事件监听器渲染列表内容组件各个生命周期功能做数据初始化将滑动处理函数做防抖处理将中的合并到绑定监听事件性能优化只有改变渲染视图渲染视图渲染保存组件更新前的容器高度根据渲染前后容器高度计算一次高度变化量解除事件监听器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-19 07:58:06',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/icon_man.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">飞向月球的猫</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/wx.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/img/wx.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/img/zfb.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url">前端开发</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>React进阶实践指南</span></a></span></div></div><h1 class="post-title" itemprop="name headline">React进阶实践指南5-理解lifeCycle</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-06-16T01:13:30.000Z" title="发表于 2025-06-16 09:13:30">2025-06-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-06-18T23:58:06.000Z" title="更新于 2025-06-19 07:58:06">2025-06-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="React进阶实践指南5-理解lifeCycle"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为中国"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>中国</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2025/06/19/685352676eddc.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://kaiyiya.github.io/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/"><header><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url">前端开发</a><a href="/tags/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/" tabindex="-1" itemprop="url">React进阶实践指南</a><h1 id="CrawlerTitle" itemprop="name headline">React进阶实践指南5-理解lifeCycle</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">飞向月球的猫</span><time itemprop="dateCreated datePublished" datetime="2025-06-16T01:13:30.000Z" title="发表于 2025-06-16 09:13:30">2025-06-16</time><time itemprop="dateCreated datePublished" datetime="2025-06-18T23:58:06.000Z" title="更新于 2025-06-19 07:58:06">2025-06-19</time></header><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在本章节中主要讲 React 的生命周期，React 类组件为开发者提供了一些生命周期钩子函数，能让开发者在 React执行的重要阶段，在钩子函数里做一些该做的事。自从 React Hooks 问世以来，函数组件也能优雅地使用 Hooks，弥补函数组件没有生命周期的缺陷。</p>
<p>希望通过本章节让你一次性搞定 React 生命周期的流程和能弄清楚在各个生命周期做些什么，第二点就是加深对 React Hooks 中 <code>useEffect</code> 和 <code>useLayoutEffect</code>的使用。</p>
<h2 id="二-类组件生命周期介绍"><a href="#二-类组件生命周期介绍" class="headerlink" title="二 类组件生命周期介绍"></a>二 类组件生命周期介绍</h2><p>在讲 React 生命周期之前，有必要先来简单聊聊 React 两个重要阶段，render 阶段和 commit 阶段，React在调和( render )阶段会深度遍历 React fiber 树，目的就是发现不同( diff)，不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数。在一次调和过程完毕之后，就到了commit阶段，commit 阶段会创建修改真实的 DOM 节点。</p>
<p>如果在一次调和的过程中，发现了一个 <code>fiber tag = 1 </code> 类组件的情况，就会按照类组件的逻辑来处理。对于类组件的处理逻辑，首先判断类组件是否已经被创建过，首先来看看源码里怎么写的。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* workloop React 处理类组件的主要功能方法 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> shouldUpdate</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span> <span class="comment">// stateNode 是 fiber 指向 类组件实例的指针。</span></span><br><span class="line">     <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123; <span class="comment">// instance 为组件实例,如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程</span></span><br><span class="line">        <span class="title function_">constructClassInstance</span>(workInProgress, <span class="title class_">Component</span>, nextProps); <span class="comment">// 组件实例将在这个方法中被new。</span></span><br><span class="line">        <span class="title function_">mountClassInstance</span>(  workInProgress,<span class="title class_">Component</span>, nextProps,renderExpirationTime ); <span class="comment">//初始化挂载组件流程</span></span><br><span class="line">        shouldUpdate = <span class="literal">true</span>; <span class="comment">// shouldUpdate 标识用来证明 组件是否需要更新。</span></span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        shouldUpdate = <span class="title function_">updateClassInstance</span>(current, workInProgress, <span class="title class_">Component</span>, nextProps, renderExpirationTime) <span class="comment">// 更新组件流程</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(shouldUpdate)&#123;</span><br><span class="line">         nextChildren = instance.<span class="title function_">render</span>(); <span class="comment">/* 执行render函数 ，得到子节点 */</span></span><br><span class="line">        <span class="title function_">reconcileChildren</span>(current,workInProgress,nextChildren,renderExpirationTime) <span class="comment">/* 继续调和子节点 */</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>几个重要概念：</p>
<ul>
<li>① <code>instance</code> 类组件对应实例。</li>
<li>② <code>workInProgress</code> 树，当前正在调和的 fiber 树 ，一次更新中，React 会自上而下深度遍历子代 fiber ，如果遍历到一个 fiber ，会把当前 fiber 指向 workInProgress。</li>
<li>③ <code>current</code> 树，在初始化更新中，current &#x3D; null ，在第一次 fiber 调和之后，会将workInProgress 树赋值给 current 树。React 来用workInProgress 和 current来确保一次更新中，快速构建，并且状态不丢失。</li>
<li>④ <code>Component</code> 就是项目中的 class 组件。</li>
<li>⑤ <code>nextProps</code> 作为组件在一次更新中新的 props 。</li>
<li>⑥ <code>renderExpirationTime</code> 作为下一次渲染的过期时间。</li>
</ul>
<p>在组件实例上可以通过 <code>_reactInternals</code> 属性来访问组件对应的 fiber 对象。在 fiber 对象上，可以通过 <code>stateNode</code> 来访问当前 fiber 对应的组件实例。两者的关系如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/1750038561366.png"></p>
<h3 id="React-类组件生命周期执行过程探秘"><a href="#React-类组件生命周期执行过程探秘" class="headerlink" title="React 类组件生命周期执行过程探秘"></a>React 类组件生命周期执行过程探秘</h3><p>React 的大部分生命周期的执行，都在 <code>mountClassInstance</code> 和 <code>updateClassInstance</code> 这两个方法中执行，所以为了让大家深入学习 React 生命周期的执行过程，我觉得有必要去揭秘这两个函数充当了什么角色。我把流程简化成 mount (初始化渲染) 和 update (更新)两个方向。</p>
<p>为了让大家更理解生命周期的执行流程，我这里分为 <strong>组件初始化</strong> ，<strong>组件更新</strong> ， <strong>组件销毁</strong> ，三大阶段分析。</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p><strong>① constructor 执行</strong></p>
<p>在 mount 阶段，首先执行的 constructClassInstance 函数，用来实例化 React 组件，在组件章节已经介绍了这个函数，组件中 constructor 就是在这里执行的。</p>
<p>在实例化组件之后，会调用 mountClassInstance 组件初始化。</p>
<p>接下来看一下 mountClassInstance 做了些什么？ 我只写了和生命周期息息相关的代码。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountClassInstance</span>(<span class="params">workInProgress,ctor,newProps,renderExpirationTime</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>;</span><br><span class="line">     <span class="keyword">const</span> getDerivedStateFromProps = ctor.<span class="property">getDerivedStateFromProps</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">/* ctor 就是我们写的类组件，获取类组件的静态方法 */</span></span><br><span class="line">     <span class="keyword">const</span> partialState = <span class="title function_">getDerivedStateFromProps</span>(nextProps, prevState); <span class="comment">/* 这个时候执行 getDerivedStateFromProps 生命周期 ，得到将合并的state */</span></span><br><span class="line">     <span class="keyword">const</span> memoizedState = partialState === <span class="literal">null</span> || partialState === <span class="literal">undefined</span> ? prevState : <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, prevState, partialState); <span class="comment">// 合并state</span></span><br><span class="line">     workInProgress.<span class="property">memoizedState</span> = memoizedState;</span><br><span class="line">     instance.<span class="property">state</span> = workInProgress.<span class="property">memoizedState</span>; <span class="comment">/* 将state 赋值给我们实例上，instance.state  就是我们在组件中 this.state获取的state*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> ctor.<span class="property">getDerivedStateFromProps</span> !== <span class="string">&#x27;function&#x27;</span> &amp;&amp;   <span class="keyword">typeof</span> instance.<span class="property">getSnapshotBeforeUpdate</span> !== <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> instance.<span class="property">componentWillMount</span> === <span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">      instance.<span class="title function_">componentWillMount</span>(); <span class="comment">/* 当 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 不存在的时候 ，执行 componentWillMount*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>② getDerivedStateFromProps 执行</strong></p>
<p>在初始化阶段，<code>getDerivedStateFromProps</code> 是第二个执行的生命周期，值得注意的是它是从 ctor 类上直接绑定的静态方法，传入 props ，state 。 返回值将和之前的 state 合并，作为新的 state ，传递给组件实例使用。</p>
<p><strong>③ componentWillMount 执行</strong></p>
<p>如果存在 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 就不会执行生命周期 <code>componentWillMount</code>。</p>
<p><strong>④ render 函数执行</strong></p>
<p>到此为止 <code>mountClassInstancec</code> 函数完成，但是上面 <code>updateClassComponent</code> 函数， 在执行完 <code>mountClassInstancec</code> 后，执行了 render 渲染函数，形成了 children ， 接下来 React 调用 reconcileChildren 方法深度调和 children 。</p>
<p><strong>⑤componentDidMount执行</strong></p>
<p>细心的同学可能发现，生命周期 <code>componentDidMount</code> 还没有出现，那么 <code>componentDidMount</code> 是如何执行的呢？上文中简单介绍了 render 和 commit 两个阶段，上述提及的几生命周期都是在 render 阶段执行的。一旦 React 调和完所有的 fiber 节点，就会到 commit 阶段，在组件初始化 commit 阶段，会调用 <code>componentDidMount</code> 生命周期。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLifeCycles</span>(<span class="params">finishedRoot,current,finishedWork</span>)&#123;</span><br><span class="line">     <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>)&#123;                             <span class="comment">/* fiber tag 在第一节讲了不同fiber类型 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;                              <span class="comment">/* 如果是 类组件 类型 */</span></span><br><span class="line">             <span class="keyword">const</span> instance = finishedWork.<span class="property">stateNode</span>        <span class="comment">/* 类实例 */</span></span><br><span class="line">             <span class="keyword">if</span>(current === <span class="literal">null</span>)&#123;                          <span class="comment">/* 类组件第一次调和渲染 */</span></span><br><span class="line">                instance.<span class="title function_">componentDidMount</span>() </span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;                                         <span class="comment">/* 类组件更新 */</span></span><br><span class="line">                instance.<span class="title function_">componentDidUpdate</span>(prevProps,prevState，instance.<span class="property">__reactInternalSnapshotBeforeUpdate</span>); </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以直观看到 <code>componentDidMount</code> 执行时机 和 <code>componentDidUpdate</code> 执行时机是相同的 ，只不过一个是针对初始化，一个是针对组件再更新。到此初始化阶段，生命周期执行完毕。</p>
<p>执行顺序：constructor -&gt; getDerivedStateFromProps &#x2F; componentWillMount -&gt; render -&gt; componentDidMount</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/1750042187998.png"></p>
<p>接下来分析一下一次组件更新中，会有哪些生命周期执行呢？</p>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>接下来一次类组件的更新阶段，到底会执行那些生命周期函数呢，回到了最开始 <code>updateClassComponent</code> 函数了，当发现 current 不为 null 的情况时，说明该类组件被挂载过，那么直接按照更新逻辑来处理。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassInstance</span>(<span class="params">current,workInProgress,ctor,newProps,renderExpirationTime</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>; <span class="comment">// 类组件实例</span></span><br><span class="line">    <span class="keyword">const</span> hasNewLifecycles =  <span class="keyword">typeof</span> ctor.<span class="property">getDerivedStateFromProps</span> === <span class="string">&#x27;function&#x27;</span>  <span class="comment">// 判断是否具有 getDerivedStateFromProps 生命周期</span></span><br><span class="line">    <span class="keyword">if</span>(!hasNewLifecycles &amp;&amp; <span class="keyword">typeof</span> instance.<span class="property">componentWillReceiveProps</span> === <span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">         <span class="keyword">if</span> (oldProps !== newProps || oldContext !== nextContext) &#123;     <span class="comment">// 浅比较 props 不相等</span></span><br><span class="line">            instance.<span class="title function_">componentWillReceiveProps</span>(newProps, nextContext);  <span class="comment">// 执行生命周期 componentWillReceiveProps </span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newState = (instance.<span class="property">state</span> = oldState);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        ctor.<span class="title function_">getDerivedStateFromProps</span>(nextProps,prevState)  <span class="comment">/* 执行生命周期getDerivedStateFromProps  ，逻辑和mounted类似 ，合并state  */</span></span><br><span class="line">        newState = workInProgress.<span class="property">memoizedState</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">let</span> shouldUpdate = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> instance.<span class="property">shouldComponentUpdate</span> === <span class="string">&#x27;function&#x27;</span> )&#123; <span class="comment">/* 执行生命周期 shouldComponentUpdate 返回值决定是否执行render ，调和子节点 */</span></span><br><span class="line">        shouldUpdate = instance.<span class="title function_">shouldComponentUpdate</span>(newProps,newState,nextContext,);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shouldUpdate)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.<span class="property">componentWillUpdate</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            instance.<span class="title function_">componentWillUpdate</span>(); <span class="comment">/* 执行生命周期 componentWillUpdate  */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>①执行生命周期 componentWillReceiveProps</strong></p>
<p>首先判断 <code>getDerivedStateFromProps</code> 生命周期是否存在，如果不存在就执行 <code>componentWillReceiveProps</code>生命周期。传入该生命周期两个参数，分别是 newProps 和 nextContext 。</p>
<p><strong>②执行生命周期 getDerivedStateFromProps</strong></p>
<p>接下来执行生命周期 <code>getDerivedStateFromProps</code>， 返回的值用于合并state，生成新的state。</p>
<p><strong>③执行生命周期 shouldComponentUpdate</strong></p>
<p>接下来执行生命周期 <code>shouldComponentUpdate</code>，传入新的 props ，新的 state ，和新的 context ，返回值决定是否继续执行 render 函数，调和子节点。这里应该注意一个问题，<code>getDerivedStateFromProps</code> 的返回值可以作为新的 state ，传递给 shouldComponentUpdate 。</p>
<p><strong>④执行生命周期 componentWillUpdate</strong></p>
<p>接下来执行生命周期 <code>componentWillUpdate</code>。updateClassInstance 方法到此执行完毕了。</p>
<p><strong>⑤执行 render 函数</strong></p>
<p>接下来会执行 render 函数，得到最新的 React element 元素。然后继续调和子节点。</p>
<p><strong>⑥执行 getSnapshotBeforeUpdate</strong></p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationLifeCycles</span>(<span class="params">current,finishedWork</span>)&#123;</span><br><span class="line">     <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:&#123;</span><br><span class="line">               <span class="keyword">const</span> snapshot = instance.<span class="title function_">getSnapshotBeforeUpdate</span>(prevProps,prevState) <span class="comment">/* 执行生命周期 getSnapshotBeforeUpdate   */</span></span><br><span class="line">                instance.<span class="property">__reactInternalSnapshotBeforeUpdate</span> = snapshot; <span class="comment">/* 返回值将作为 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 生命周期  */</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getSnapshotBeforeUpdate</code> 的执行也是在 commit 阶段，commit 阶段细分为 <code>before Mutation</code>( DOM 修改前)，<code>Mutation</code> ( DOM 修改)，<code>Layout</code>( DOM 修改后) 三个阶段，getSnapshotBeforeUpdate 发生在 <code>before Mutation</code> 阶段，生命周期的返回值，将作为第三个参数 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 。</p>
<p><strong>⑦执行 componentDidUpdate</strong></p>
<p>接下来执行生命周期 componentDidUpdate ，此时 DOM 已经修改完成。可以操作修改之后的 DOM 。到此为止更新阶段的生命周期执行完毕。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/1750043591826.png"></p>
<p>更新阶段对应的生命周期的执行顺序：</p>
<p>componentWillReceiveProps( props 改变) &#x2F; getDerivedStateFromProp -&gt;shouldComponentUpdate -&gt; componentWillUpdate -&gt; render  -&gt;<br>getSnapshotBeforeUpdate -&gt;  componentDidUpdate</p>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callComponentWillUnmountWithTimer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    instance.<span class="title function_">componentWillUnmount</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>①执行生命周期 componentWillUnmount</strong></p>
<p>销毁阶段就比较简单了，在一次调和更新中，如果发现元素被移除，就会打对应的 Deletion 标签 ，然后在 commit 阶段就会调用 <code>componentWillUnmount</code> 生命周期，接下来统一卸载组件以及 DOM 元素。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/1750043863311.png"></p>
<p>三个阶段生命周期+无状态组件总览图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/1750129624727.png"></p>
<h3 id="React-各阶段生命周期能做些什么"><a href="#React-各阶段生命周期能做些什么" class="headerlink" title="React 各阶段生命周期能做些什么"></a>React 各阶段生命周期能做些什么</h3><p>上面部分详细的介绍了 React 各生命周期的执行时机和执行顺序。接下来分别介绍一下各个 lifecycle 能做些什么？</p>
<h4 id="1-constructor"><a href="#1-constructor" class="headerlink" title="1 constructor"></a>1 constructor</h4><p>React 在不同时期抛出不同的生命周期钩子，也就意味这这些生命周期钩子的使命。上面讲过 constructor 在类组件创建实例时调用，而且初始化的时候执行一次，所以可以在 constructor 做一些初始化的工作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)        <span class="comment">// 执行 super ，别忘了传递props,才能在接下来的上下文中，获取到props。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;       <span class="comment">//① 可以用来初始化state，比如可以用来获取路由中的</span></span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>) <span class="comment">/* ② 绑定 this */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleInputChange</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleInputChange</span> , <span class="number">500</span>) <span class="comment">/* ③ 绑定防抖函数，防抖 500 毫秒 */</span></span><br><span class="line">    <span class="keyword">const</span> _render = <span class="variable language_">this</span>.<span class="property">render</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">render</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _render.<span class="title function_">bind</span>(<span class="variable language_">this</span>)  <span class="comment">/* ④ 劫持修改类组件上的一些生命周期 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 点击事件 */</span></span><br><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>)&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">/* 表单输入 */</span></span><br><span class="line"><span class="title function_">handleInputChange</span>(<span class="params"></span>)&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>constructor 作用：</p>
<ul>
<li>初始化 state ，比如可以用来截取路由中的参数，赋值给 state 。</li>
<li>对类组件的事件做一些处理，比如绑定 this ， 节流，防抖等。</li>
<li>对类组件进行一些必要生命周期的劫持，渲染劫持，这个功能更适合反向继承的HOC ，在 HOC 环节，会详细讲解反向继承这种模式。</li>
</ul>
<h4 id="2-getDerivedStateFromProps"><a href="#2-getDerivedStateFromProps" class="headerlink" title="2 getDerivedStateFromProps"></a>2 getDerivedStateFromProps</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getDerivedStateFromProps</span>(nextProps,prevState)</span><br></pre></td></tr></table></figure>

<p>两个参数：</p>
<ul>
<li>nextProps 父组件新传递的 props ;</li>
<li>prevState 传入 getDerivedStateFromProps 待合并的 state 。</li>
</ul>
<p><code>getDerivedStateFromProps</code> 方法作为类的静态属性方法执行，内部是访问不到 <code>this</code> 的，它更趋向于纯函数，从源码中就能够体会到 React 对该生命周期定义为取缔 componentWillMount 和 componentWillReceiveProps 。</p>
<p>如果把 getDerivedStateFromProps 英文分解 get ｜ Derived | State ｜ From ｜ Props  翻译  <strong>得到 派生的 state 从 props 中</strong> ，正如它的名字一样，这个生命周期用于，在初始化和更新阶段，接受父组件的 props 数据， 可以对 props 进行格式化，过滤等操作，返回值将作为新的 state 合并到 state 中，供给视图渲染层消费。</p>
<p>从源码中可以看到，只要组件更新，就会执行 <code>getDerivedStateFromProps</code>，不管是 props 改变，还是 setState ，或是 forceUpdate 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">newProps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type &#125; = newProps</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fruit&#x27;</span> : </span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">list</span>:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span> ] &#125; <span class="comment">/* ① 接受 props 变化 ， 返回值将作为新的 state ，用于 渲染 或 传递给s houldComponentUpdate */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;vegetables&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">list</span>:[<span class="string">&#x27;菠菜&#x27;</span>,<span class="string">&#x27;西红柿&#x27;</span>,<span class="string">&#x27;土豆&#x27;</span>]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123; this.state.list.map((item)=&gt;<span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> &gt;</span>&#123; item  &#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>) &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getDerivedStateFromProps 作用：</p>
<ul>
<li>代替 componentWillMount 和 componentWillReceiveProps</li>
<li>组件初始化或者更新时，将 props 映射到 state。</li>
<li>返回值与 state 合并完，可以作为 shouldComponentUpdate 第二个参数  newState，可以判断是否渲染组件。(请不要把 getDerivedStateFromProps 和 shouldComponentUpdate强行关联到一起，两者没有必然联系)</li>
</ul>
<h4 id="3-componentWillMount-和-UNSAFE-componentWillMount"><a href="#3-componentWillMount-和-UNSAFE-componentWillMount" class="headerlink" title="3 componentWillMount 和 UNSAFE_componentWillMount"></a>3 componentWillMount 和 UNSAFE_componentWillMount</h4><p>在 React V16.3 componentWillMount ，componentWillReceiveProps ， componentWillUpdate 三个生命周期加上了不安全的标识符 <code>UNSAFE</code>，变成了如下形式，在目前最新的版本React <code>V17.0.2 </code>也没有废弃这三个生命周期。可能不久之后更高级的版本会被废除吧，首先先来看一下为什么要加 <code>UNSAFE</code>，首先根据源码，大家有没有发现一个问题，就是这三个生命周期，都是在render 之前执行的，React 对于执行 render 函数有着像 shouldUpdate 等条件制约，但是对于执行在 render之前生命周期没有限制，存在一定隐匿风险，如果 updateClassInstance 执行多次，React<br>开发者滥用这几个生命周期，可能导致生命周期内的上下文多次被执行。</p>
<ul>
<li>UNSAFE_componentWillMount</li>
<li>UNSAFE_componentWillReceiveProps</li>
<li>UNSAFE_componentWillUpdate</li>
</ul>
<p>UNSAFE_componentWillMount 的作用还是做一些初始化操作，但是不建议在这个生命周期写，毕竟未来 React 可能完全取缔它。</p>
<h4 id="4-componentWillReceiveProps-和-UNSAFE-componentWillReceiveProps"><a href="#4-componentWillReceiveProps-和-UNSAFE-componentWillReceiveProps" class="headerlink" title="4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps"></a>4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps</h4><p>UNSAFE_componentWillReceiveProps 函数的执行是在更新组件阶段，该生命周期执行驱动是因为父组件更新带来的props 修改，但是只要父组件触发 render 函数，调用 React.createElement 方法，那么 props就会被重新创建，生命周期 componentWillReceiveProps 就会执行了。这就解释了即使 props 没变，该生命周期也会执行。</p>
<p>componentWillReceiveProps 可以用来干什么？我把上面例子修改一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">UNSAFE_componentWillReceiveProps</span>(<span class="params">newProps</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; type &#125; = newProps</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;父组件render执行&#x27;</span>) <span class="comment">/*  ① 监听父组件执行render  */</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;  <span class="comment">/* ② 异步控制props改变，派生出来的 state 的修改  */</span></span><br><span class="line">            <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;fruit&#x27;</span> : </span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">list</span>:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span> ] &#125;) </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;vegetables&#x27;</span>:</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">list</span>:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span> ] &#125;) </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>componentWillReceiveProps 可以用来监听父组件是否执行 render 。</li>
<li>componentWillReceiveProps 可以用来接受 props 改变，组件可以根据props改变，来决定是否更新<br>state ，因为可以访问到 this ， 所以可以在异步成功回调(接口请求数据)改变 state 。这个是<br>getDerivedStateFromProps  不能实现的。</li>
</ul>
<p>但是笔者不建议用这种方式，props 改变，再触发 componentWillReceiveProps<br>异步请求数据渲染，这样首先在没做优化前提下会带来两次子组件的更新，第一次 props 改变，第二次 props 改变，异步改变state<br>。其次该生命周期的不安全性。再者需要在该生命周期内部，设置大量的条件判断语句，通过 this.props ， nextProps 判断<br>props 到底改变与否。所以完全可以换一种思路，那就是 <strong>状态提升</strong> ，把数据层完全托管父组件，子组件没有副作用，只负责渲染父组件传递的 props 即可。</p>
<p><strong>｜——–问与答———｜</strong></p>
<p>问：当 props 不变的前提下， PureComponent 组件能否阻止 componentWillReceiveProps 执行？</p>
<p>答案是否定的，componentWillReceiveProps 生命周期的执行，和纯组件没有关系，纯组件是在componentWillReceiveProps 执行之后浅比较 props 是否发生变化。所以 PureComponent下不会阻止该生命周期的执行。</p>
<h4 id="5-componentWillUpdate-和-UNSAFE-componentWillUpdate"><a href="#5-componentWillUpdate-和-UNSAFE-componentWillUpdate" class="headerlink" title="5 componentWillUpdate 和 UNSAFE_componentWillUpdate"></a>5 componentWillUpdate 和 UNSAFE_componentWillUpdate</h4><p>UNSAFE_componentWillUpdate 可以意味着在更新之前，此时的 DOM 还没有更新。在这里可以做一些获取 DOM的操作。就比如说在一次更新中，保存 DOM 之前的信息(记录上一次位置)。但是 React 已经出了新的生命周期getSnapshotBeforeUpdate 来代替 UNSAFE_componentWillUpdate。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">UNSAFE_componentWillUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">getPostion</span>(<span class="variable language_">this</span>.<span class="property">node</span>) <span class="comment">/* 获取元素节点 node 位置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>获取组件更新之前的状态。比如 DOM 元素位置等。</li>
</ul>
<h4 id="6-render"><a href="#6-render" class="headerlink" title="6 render"></a>6 render</h4><p>还记得在第一节 jsx 主要讲了 render 之后会成什么样子。所谓 render 函数，就是 jsx 的各个元素被React.createElement 创建成 React element 对象的形式。一次 render 的过程，就是创建React.element 元素的过程。</p>
<ul>
<li>那么可以在render里面做一些,<strong>createElement创建元素</strong> , <strong>cloneElement 克隆元素</strong> ，<strong>React.children 遍历 children</strong> 的操作。</li>
</ul>
<h4 id="7-getSnapshotBeforeUpdate"><a href="#7-getSnapshotBeforeUpdate" class="headerlink" title="7 getSnapshotBeforeUpdate"></a>7 getSnapshotBeforeUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps,preState</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>两个参数：</p>
<ul>
<li>prevProps更新前的props ；</li>
<li>preState更新前的state；</li>
</ul>
<p>把 getSnapshotBeforeUpdate 用英文解释一下 ， <strong>get | snap shot | before | update</strong> ， 中文翻译为  <strong>获取更新前的快照</strong> ，可以进一步理解为 获取更新前 DOM 的状态。见名知意，上面说过该生命周期是在 commit 阶段的before Mutation ( DOM 修改前)，此时DOM 还没有更新，但是在接下来的 Mutation 阶段会被替换成真实 DOM 。此时是获取 DOM信息的最佳时期，getSnapshotBeforeUpdate 将返回一个值作为一个 <code>snapShot</code>(快照)，传递给 componentDidUpdate作为第三个参数。</p>
<p>注意：如果没有返回值会给予警告⚠️，如果没有 <code>componentDidUpdate</code>也会给予警告。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps,preState</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="title function_">getComputedStyle</span>(<span class="variable language_">this</span>.<span class="property">node</span>) </span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">/* 传递更新前的元素位置 */</span></span><br><span class="line">        <span class="attr">cx</span>:style.<span class="property">cx</span>,</span><br><span class="line">        <span class="attr">cy</span>:style.<span class="property">cy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">    <span class="comment">/* 获取元素绘制之前的位置 */</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这个快照 <code>snapShot</code> 不限于 DOM 的信息，也可以是根据 DOM 计算出来产物。</p>
<p>作用：</p>
<ul>
<li>getSnapshotBeforeUpdate 这个生命周期意义就是配合componentDidUpdate 一起使用，计算形成一个 snapShot 传递给 componentDidUpdate 。保存一次更新前的信息。</li>
</ul>
<h4 id="8-componentDidUpdate"><a href="#8-componentDidUpdate" class="headerlink" title="8 componentDidUpdate"></a>8 componentDidUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="title function_">getComputedStyle</span>(<span class="variable language_">this</span>.<span class="property">node</span>)</span><br><span class="line">    <span class="keyword">const</span> newPosition = &#123; <span class="comment">/* 获取元素最新位置信息 */</span></span><br><span class="line">        <span class="attr">cx</span>:style.<span class="property">cx</span>,</span><br><span class="line">        <span class="attr">cy</span>:style.<span class="property">cy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个参数：</p>
<ul>
<li>prevProps 更新之前的 props ；</li>
<li>prevState 更新之前的 state ；</li>
<li>snapshot 为 getSnapshotBeforeUpdate 返回的快照，可以是更新前的 DOM 信息。</li>
</ul>
<p>作用</p>
<ul>
<li>componentDidUpdate 生命周期执行，此时 DOM 已经更新，可以直接获取 DOM 最新状态。这个函数里面如果想要使用 setState ，一定要加以限制，否则会引起无限循环。</li>
<li>接受 getSnapshotBeforeUpdate 保存的快照信息。</li>
</ul>
<h4 id="9-componentDidMount"><a href="#9-componentDidMount" class="headerlink" title="9 componentDidMount"></a>9 componentDidMount</h4><p>componentDidMount 生命周期执行时机和 componentDidUpdate 一样，一个是在 <strong>初始化</strong> ，一个是 <strong>组件更新</strong> 。此时 DOM 已经创建完，既然 DOM 已经创建挂载，就可以做一些基于 DOM 操作，DOM 事件监听器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 事件监听 */</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getData</span>() <span class="comment">/* 数据请求 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>可以做一些关于 DOM 操作，比如基于 DOM 的事件监听器。</li>
<li>对于初始化向服务器请求数据，渲染视图，这个生命周期也是蛮合适的。</li>
</ul>
<h4 id="10-shouldComponentUpdate"><a href="#10-shouldComponentUpdate" class="headerlink" title="10 shouldComponentUpdate"></a>10 shouldComponentUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps,newState,nextContext</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>shouldComponentUpdate 三个参数，第一个参数新的 props ，第二个参数新的 state ，第三个参数新的 context 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps,newState</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newProps.<span class="property">a</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">a</span> )&#123; <span class="comment">/* props中a属性发生变化 渲染组件 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newState.<span class="property">b</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">b</span> )&#123; <span class="comment">/* state 中b属性发生变化 渲染组件 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">/* 否则组件不渲染 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个生命周期，一般用于性能优化，shouldComponentUpdate 返回值决定是否重新渲染的类组件。需要重点关注的是第二个参数newState ，如果有 getDerivedStateFromProps 生命周期 ，它的返回值将合并到 newState ，供shouldComponentUpdate 使用。</li>
</ul>
<h4 id="11-componentWillUnmount"><a href="#11-componentWillUnmount" class="headerlink" title="11 componentWillUnmount"></a>11 componentWillUnmount</h4><p>componentWillUnmount 是组件销毁阶段唯一执行的生命周期，主要做一些收尾工作，比如清除一些可能造成内存泄漏的定时器，延时器，或者是一些事件监听器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timer</span>)  <span class="comment">/* 清除延时器 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handerClick</span>) <span class="comment">/* 卸载事件监听器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用</p>
<ul>
<li>清除延时器，定时器。</li>
<li>一些基于 DOM 的操作，比如事件监听器。</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleDemo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 构造函数 (初始化state和绑定方法)</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1. constructor&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">snapshotTest</span>: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 静态方法，从props派生state (在初始挂载和更新时都会调用)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2. getDerivedStateFromProps&#x27;</span>, &#123; nextProps, prevState &#125;);</span><br><span class="line">    <span class="comment">// 通常用于props变化时更新state</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.<span class="property">initialCount</span> !== prevState.<span class="property">count</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: nextProps.<span class="property">initialCount</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 即将过时的挂载前方法 (不推荐使用)</span></span><br><span class="line">  <span class="title function_">UNSAFE_componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3. UNSAFE_componentWillMount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 即将过时的props接收方法 (不推荐使用)</span></span><br><span class="line">  <span class="title function_">UNSAFE_componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4. UNSAFE_componentWillReceiveProps&#x27;</span>, nextProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 即将过时的更新前方法 (不推荐使用)</span></span><br><span class="line">  <span class="title function_">UNSAFE_componentWillUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5. UNSAFE_componentWillUpdate&#x27;</span>, &#123; nextProps, nextState &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. 渲染方法 (必须的)</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6. render&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;lifecycle-demo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>生命周期演示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>计数: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件传递的初始值: &#123;this.props.initialCount&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>增加计数<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.onUnmount&#125;</span>&gt;</span>卸载组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. 获取更新前快照 (在DOM更新前调用)</span></span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7. getSnapshotBeforeUpdate&#x27;</span>, &#123; prevProps, prevState &#125;);</span><br><span class="line">    <span class="comment">// 返回的值会传递给componentDidUpdate</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">fromSnapshot</span>: <span class="string">&#x27;更新前快照数据&#x27;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8. 更新完成方法</span></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8. componentDidUpdate&#x27;</span>, &#123; </span><br><span class="line">      prevProps, </span><br><span class="line">      prevState, </span><br><span class="line">      <span class="attr">currentState</span>: <span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">      snapshot</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. 挂载完成方法 (适合网络请求)</span></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9. componentDidMount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10. 性能优化方法 (决定是否重新渲染)</span></span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10. shouldComponentUpdate&#x27;</span>, &#123; nextProps, nextState &#125;);</span><br><span class="line">    <span class="comment">// 只有当计数变化时才更新</span></span><br><span class="line">    <span class="keyword">return</span> nextState.<span class="property">count</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 11. 卸载前清理方法 (清除定时器/取消请求)</span></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11. componentWillUnmount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义方法</span></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">ParentComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">showDemo</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">initialCount</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">version</span>: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  toggleComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">prev</span> =&gt;</span> (&#123; <span class="attr">showDemo</span>: !prev.<span class="property">showDemo</span> &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  changeProps = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">prev</span> =&gt;</span> (&#123; </span><br><span class="line">      <span class="attr">initialCount</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>),</span><br><span class="line">      <span class="attr">version</span>: prev.<span class="property">version</span> + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;parent-component&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>React生命周期演示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.toggleComponent&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.state.showDemo ? &#x27;卸载组件&#x27; : &#x27;挂载组件&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeProps&#125;</span>&gt;</span>更改Props<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span></span><br><span class="line"><span class="language-xml">        &#123;this.state.showDemo &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">LifecycleDemo</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">key</span>=<span class="string">&#123;this.state.version&#125;</span> // <span class="attr">强制重新创建组件</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">initialCount</span>=<span class="string">&#123;this.state.initialCount&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onUnmount</span>=<span class="string">&#123;this.toggleComponent&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          /&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期调用顺序说明："><a href="#生命周期调用顺序说明：" class="headerlink" title="生命周期调用顺序说明："></a>生命周期调用顺序说明：</h4><p><strong>1. 组件挂载阶段：</strong></p>
<ul>
<li><code>constructor()</code>：初始化state和绑定方法</li>
<li><code>getDerivedStateFromProps()</code>：从props派生state</li>
<li><code>UNSAFE_componentWillMount()</code>：即将废弃的挂载前方法</li>
<li><code>render()</code>：渲染UI</li>
<li><code>componentDidMount()</code>：挂载后执行（适合网络请求）</li>
</ul>
<p><strong>2. 组件更新阶段（props或state变化）：</strong></p>
<ul>
<li><code>UNSAFE_componentWillReceiveProps()</code>：即将废弃的props接收方法</li>
<li><code>getDerivedStateFromProps()</code>：从新props派生state</li>
<li><code>shouldComponentUpdate()</code>：决定是否重新渲染</li>
<li><code>UNSAFE_componentWillUpdate()</code>：即将废弃的更新前方法</li>
<li><code>render()</code>：重新渲染UI</li>
<li><code>getSnapshotBeforeUpdate()</code>：获取DOM更新前的信息</li>
<li><code>componentDidUpdate()</code>：更新后执行</li>
</ul>
<p><strong>3. 组件卸载阶段：</strong></p>
<ul>
<li><code>componentWillUnmount()</code>：卸载前清理（清除定时器&#x2F;取消请求）</li>
</ul>
<p>注意事项：</p>
<ol>
<li><strong>UNSAFE方法</strong> ：标记为UNSAFE的方法（<code>componentWillMount</code>, <code>componentWillReceiveProps</code>, <code>componentWillUpdate</code>）已在React 17+中弃用，建议避免使用</li>
<li><strong>getDerivedStateFromProps</strong> ：是静态方法，不能访问 <code>this</code></li>
<li><strong>getSnapshotBeforeUpdate</strong> ：必须与 <code>componentDidUpdate</code>配合使用</li>
<li><strong>shouldComponentUpdate</strong> ：通过返回 <code>true/false</code>控制更新，用于性能优化</li>
<li><strong>key属性</strong> ：父组件中使用 <code>key</code>强制重置子组件状态</li>
</ol>
<h4 id="现代React开发建议："><a href="#现代React开发建议：" class="headerlink" title="现代React开发建议："></a>现代React开发建议：</h4><ol>
<li>使用函数组件 + Hooks替代类组件</li>
<li>避免使用已弃用的生命周期方法</li>
<li>状态管理优先使用 <code>useState</code>&#x2F;<code>useReducer</code></li>
<li>副作用处理使用 <code>useEffect</code></li>
<li>性能优化使用 <code>React.memo</code>和 <code>useMemo</code>&#x2F;<code>useCallback</code></li>
</ol>
<h2 id="3-函数组件生命周期替代方案"><a href="#3-函数组件生命周期替代方案" class="headerlink" title="3 函数组件生命周期替代方案"></a>3 函数组件生命周期替代方案</h2><p>React hooks也提供了 api ，用于弥补函数组件没有生命周期的缺陷。其原理主要是运用了 hooks 里面的 <code>useEffect</code> 和 <code>useLayoutEffect</code>。</p>
<h3 id="1-useEffect-和-useLayoutEffect"><a href="#1-useEffect-和-useLayoutEffect" class="headerlink" title="1 useEffect 和 useLayoutEffect"></a>1 useEffect 和 useLayoutEffect</h3><p><strong>useEffect</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> destory</span><br><span class="line">&#125;,dep)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>useEffect 第一个参数 callback, 返回的 destory ， destory 作为下一次callback执行之前调用，用于清除上一次 callback 产生的副作用。</p>
<p>第二个参数作为依赖项，是一个数组，可以有多个依赖项，依赖项改变，执行上一次callback 返回的 destory ，和执行新的 effect 第一个参数 callback 。</p>
<p>对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会向 <code>setTimeout</code>回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。</p>
<p><strong>useLayoutEffect:</strong></p>
<p>useLayoutEffect 和 useEffect 不同的地方是采用了同步执行，那么和useEffect有什么区别呢？</p>
<ul>
<li>首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 DOM信息，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect ，那 useEffect 执行是在浏览器绘制视图之后，接下来又改DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。</li>
<li>useLayoutEffect callback 中代码执行会阻塞浏览器绘制。</li>
</ul>
<p><strong>一句话概括如何选择 useEffect 和 useLayoutEffect ：修改 DOM ，改变布局就用 useLayoutEffect ，其他情况就用 useEffect 。</strong></p>
<p><strong>｜——–问与答———｜</strong></p>
<p>问：React.useEffect 回调函数 和 componentDidMount &#x2F; componentDidUpdate 执行时机有什么区别 ？</p>
<p>答：useEffect 对 React 执行栈来看是异步执行的，而 componentDidMount &#x2F;componentDidUpdate 是同步执行的，useEffect代码不会阻塞浏览器绘制。在时机上 ，componentDidMount &#x2F;componentDidUpdate 和 useLayoutEffect 更类似。</p>
<p><strong>｜———end———-｜</strong></p>
<h3 id="2-useInsertionEffect"><a href="#2-useInsertionEffect" class="headerlink" title="2 useInsertionEffect"></a>2 useInsertionEffect</h3><p>useInsertionEffect 是在 React v18 新添加的 hooks ，它的用法和 useEffect 和 useLayoutEffect 一样。那么这个 hooks 用于什么呢?</p>
<p>在介绍 useInsertionEffect 用途之前，先看一下 useInsertionEffect 的执行时机。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useEffect 执行&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useLayoutEffect 执行&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useInsertionEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useInsertionEffect 执行&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure>

<p>打印：<br>useInsertionEffect 执行<br>useLayoutEffect 执行<br>useEffect 执行</p>
<p>可以看到 useInsertionEffect 的执行时机要比 useLayoutEffect 提前，useLayoutEffect 执行的时候 DOM 已经更新了，但是在 useInsertionEffect 的执行的时候，DOM 还没有更新。</p>
<p>本质上 useInsertionEffect 主要是解决 CSS-in-JS 在渲染中注入样式的性能问题。这个 hooks 主要是应用于这个场景，在其他场景下 React 不期望用这个 hooks 。</p>
<p>CSS-in-JS 的注入会引发哪些问题呢？ 首先看部分 CSS-in-JS 的实现原理，拿 Styled-components为例子，通过styled-components，你可以使用ES6的标签模板字符串语法（Tagged Templates）为需要 styled 的 Component 定义一系列CSS属性，当该组件的JS代码被解析执行的时候，styled-components 会动态生成一个 CSS选择器，并把对应的 CSS 样式通过 style 标签的形式插入到 head 标签里面。动态生成的 CSS选择器会有一小段哈希值来保证全局唯一性来避免样式发生冲突。这种模式下本质上是动态生成 style 标签。</p>
<p>明白了 Styled-components 原理之后，再来看一下，如果在 useLayoutEffect 使用 CSS-in-JS 会造成哪里问题呢？</p>
<ul>
<li>首先 useLayoutEffect 执行的时机 DOM 已经更新完成，布局也已经确定了，剩下的就是交给浏览器绘制就行了。</li>
<li>如果在 useLayoutEffect 动态生成 style 标签，那么会再次影响布局，导致浏览器再次重回和重排。</li>
</ul>
<p>这个是时候 useInsertionEffect 的作用就出现了，useInsertionEffect 的执行在 DOM 更新前，所以此时使用 CSS-in-JS 避免了浏览器出现再次重回和重排的可能，解决了性能上的问题。</p>
<p>接下来我们模拟一下在 useInsertionEffect 使用 CSS-in-JS 流程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useInsertionEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="comment">/* 动态创建 style 标签插入到 head 中 */</span></span><br><span class="line">     <span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>)</span><br><span class="line">     style.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">       .css-in-js&#123;</span></span><br><span class="line"><span class="string">         color: red;</span></span><br><span class="line"><span class="string">         font-size: 20px;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">     `</span></span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style)</span><br><span class="line">  &#125;,[])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;css-in-js&quot;</span> &gt;</span> hello , useInsertionEffect <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/1750127582097.png"></p>
<p>此时 div 的字体颜色和字体大小已经更改。上述详细的介绍了 useEffect，useLayoutEffect 和 useInsertionEffect，接下来拿 useEffect 做参考，详细介绍一下函数组件怎么实现生命周期的替代方案的。</p>
<h3 id="3-componentDidMount-替代方案"><a href="#3-componentDidMount-替代方案" class="headerlink" title="3 componentDidMount 替代方案"></a>3 componentDidMount 替代方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/* 请求数据 ， 事件监听 ， 操纵dom */</span></span><br><span class="line">&#125;,[])  <span class="comment">/* 切记 dep = [] */</span></span><br></pre></td></tr></table></figure>

<p>这里要记住 <code>dep = []</code> ，这样当前 effect 没有任何依赖项，也就只有初始化执行一次。</p>
<h3 id="4-componentWillUnmount-替代方案"><a href="#4-componentWillUnmount-替代方案" class="headerlink" title="4 componentWillUnmount 替代方案"></a>4 componentWillUnmount 替代方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 请求数据 ， 事件监听 ， 操纵dom ， 增加定时器，延时器 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">/* 解除事件监听器 ，清除定时器，延时器 */</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;,[])<span class="comment">/* 切记 dep = [] */</span></span><br></pre></td></tr></table></figure>

<p>在 componentDidMount 的前提下，useEffect 第一个函数的返回函数，可以作为 componentWillUnmount 使用。</p>
<h3 id="5-componentWillReceiveProps-代替方案"><a href="#5-componentWillReceiveProps-代替方案" class="headerlink" title="5 componentWillReceiveProps 代替方案"></a>5 componentWillReceiveProps 代替方案</h3><p>说 useEffect 代替 componentWillReceiveProps 着实有点牵强。</p>
<ul>
<li>首先因为二者的执行阶段根本不同，一个是在render阶段，一个是在commit阶段。</li>
<li>其次  <strong>useEffect 会初始化执行一次</strong> ，但是 componentWillReceiveProps 只有组件更新 props 变化的时候才会执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props变化：componentWillReceiveProps&#x27;</span>)</span><br><span class="line">&#125;,[ props ])</span><br></pre></td></tr></table></figure>

<p>此时依赖项就是 props，props 变化，执行此时的 useEffect 钩子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props中number变化：componentWillReceiveProps&#x27;</span>)</span><br><span class="line">&#125;,[ props.<span class="property">number</span> ]) <span class="comment">/* 当前仅当 props中number变化，执行当前effect钩子 */</span></span><br></pre></td></tr></table></figure>

<p>useEffect 还可以针对 props 的某一个属性进行追踪。此时的依赖项为 props 的追踪属性。如上述代码，只有 props 中 number 变化，执行 effect 。</p>
<h3 id="6-componentDidUpdate-替代方案"><a href="#6-componentDidUpdate-替代方案" class="headerlink" title="6 componentDidUpdate 替代方案"></a>6 componentDidUpdate 替代方案</h3><p>useEffect 和 componentDidUpdate 在执行时期虽然有点差别，useEffect是异步执行，componentDidUpdate 是同步执行 ，但都是在 commit 阶段 。但是向上面所说 useEffect会默认执行一次，而 componentDidUpdate 只有在组件更新完成后执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件更新完成：componentDidUpdate &#x27;</span>)   </span><br><span class="line">&#125;) <span class="comment">/* 没有 dep 依赖项 */</span></span><br></pre></td></tr></table></figure>

<p>注意此时useEffect没有第二个参数。</p>
<p>没有第二个参数，那么每一次执行函数组件，都会执行该 effect。</p>
<h3 id="7-完整代码和效果"><a href="#7-完整代码和效果" class="headerlink" title="7 完整代码和效果"></a>7 完整代码和效果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FunctionLifecycle</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ num , setNum ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 请求数据 ， 事件监听 ， 操纵dom  ， 增加定时器 ， 延时器 */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件挂载完成：componentDidMount&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">/* 解除事件监听器 ，清除 */</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件销毁：componentWillUnmount&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])<span class="comment">/* 切记 dep = [] */</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props变化：componentWillReceiveProps&#x27;</span>)</span><br><span class="line">    &#125;,[ props ])</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">/*  */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; 组件更新完成：componentDidUpdate &#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> props : &#123; props.number &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> states : &#123; num &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNum(state=&gt;state + 1) &#125;   &gt;改变state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="title function_">default</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ isRender , setRender ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; isRender &amp;&amp;  <span class="tag">&lt;<span class="name">FunctionLifecycle</span> <span class="attr">number</span>=<span class="string">&#123;number&#125;</span>  /&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumber(state =&gt; state + 1 ) &#125; &gt; 改变props  <span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setRender(false) &#125; &gt;卸载组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-实践-实现一个ScrollView组件"><a href="#四-实践-实现一个ScrollView组件" class="headerlink" title="四 实践-实现一个ScrollView组件"></a>四 实践-实现一个ScrollView组件</h2><p>接下来为了让大家加深对生命周期各阶段的理解，我写了一个 demo ，编写一个类似小程序或是 webView 中的 scrollView 组件，主要用于长列表渲染，滑动底部请求渲染列表。组件本身功能不重要，实现细节也不需要太纠结，本节讲的是生命周期，明白生命周期的各个阶段应该做些什么才重要。</p>
<p><strong>使用:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* item 完全是单元项的渲染ui */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Item</span>(<span class="params">&#123;item&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;goods_item&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;item.giftImage&#125;</span> <span class="attr">className</span>=<span class="string">&quot;item_image&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;item_content&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;goods_name&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;item.giftName&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;hold_price&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;new_price&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;new_price&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;one view&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        ¥ &#123;item.price&#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">&#x27;go_share  go_text&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> [ data , setData ] = <span class="title function_">useState</span>(&#123; <span class="attr">list</span>:[],<span class="attr">page</span>:<span class="number">0</span>,<span class="attr">pageCount</span>:<span class="number">1</span>  &#125;) <span class="comment">/* 记录列表数据 */</span></span><br><span class="line">    <span class="comment">/* 请求数据 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getData</span> = <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="property">page</span> === data.<span class="property">pageCount</span>) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有数据了～&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetchData</span>(data.<span class="property">page</span> + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">code</span> === <span class="number">0</span>) <span class="title function_">setData</span>(&#123;</span><br><span class="line">            ...res,</span><br><span class="line">            <span class="attr">list</span>:res.<span class="property">page</span> === <span class="number">1</span> ?  res.<span class="property">list</span> : data.<span class="property">list</span>.<span class="title function_">concat</span>(res.<span class="property">list</span>) </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 滚动到底部触发 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handerScrolltolower</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll已经到底部&#x27;</span>)</span><br><span class="line">        <span class="title function_">getData</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 初始化请求数据 */</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">getData</span>()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ScrollView</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">data</span>=<span class="string">&#123;</span> <span class="attr">data</span> &#125;       /*  */</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">component</span>=<span class="string">&#123;</span> <span class="attr">Item</span> &#125;  /* <span class="attr">Item</span> <span class="attr">渲染的单元组件</span> */</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scrolltolower</span>=<span class="string">&#123;</span> <span class="attr">handerScrolltolower</span> &#125; </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scroll</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;&#125;&#125; </span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScrollView</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="comment">/* -----自定义事件---- */</span></span><br><span class="line">    <span class="comment">/* 控制滚动条滚动 */</span></span><br><span class="line">      handerScroll=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; scroll &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        scroll &amp;&amp; <span class="title function_">scroll</span>(e)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">handerScrolltolower</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 判断滚动条是否到底部 */</span></span><br><span class="line">    <span class="title function_">handerScrolltolower</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; scrolltolower &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">       <span class="keyword">const</span> &#123; scrollHeight , scrollTop ,  offsetHeight &#125; = <span class="variable language_">this</span>.<span class="property">node</span> </span><br><span class="line">       <span class="keyword">if</span>(scrollHeight === scrollTop + offsetHeight)&#123; <span class="comment">/* 到达容器底部位置 */</span></span><br><span class="line">           scrolltolower &amp;&amp; <span class="title function_">scrolltolower</span>()</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---——---生命周期------- */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123; <span class="comment">/* 初始化 Data */</span></span><br><span class="line">            <span class="attr">list</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handerScrolltolower</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handerScrolltolower</span>,<span class="number">200</span>) <span class="comment">/* 防抖处理 */</span>           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 接收props, 合并到state */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">newProps</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = newProps</span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            list : data.<span class="property">list</span> || [] ,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 性能优化，只有列表数据变化，渲染列表 */</span></span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps,newState</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> newState.<span class="property">list</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取更新前容器高度 */</span></span><br><span class="line">    <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">scrollHeight</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取更新后容器高度 */</span></span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scrollView容器高度变化:&#x27;</span> , <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">scrollHeight</span> - snapshot  )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 绑定事件监听器 - 监听scorll事件 */</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handerScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 解绑事件监听器 */</span></span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handerScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; list &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">const</span> &#123; component &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list_box&quot;</span>  <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> this.node = node &#125;  &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> &gt;</span>   </span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    list.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">                        React.createElement(component,&#123; item , key: item.id  &#125;) //渲染 Item 列表内容。</span></span><br><span class="line"><span class="language-xml">                    ))</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>scrollview组件各个生命周期功能：</p>
<ul>
<li><code>constructor</code>： 做数据初始化，将滑动处理函数，做防抖处理。</li>
<li><code>getDerivedStateFromProps</code>: 将 props 中的 list ，合并到 state 。</li>
<li><code>componentDidMount</code>: 绑定监听 scroll 事件。</li>
<li><code>shouldComponentUpdate</code>：性能优化，只有 list 改变，渲染视图。</li>
<li><code>render</code>: 渲染视图，渲染 Item 。</li>
<li><code>getSnapshotBeforeUpdate</code>：保存组件更新前的 scrollview 容器高度。</li>
<li><code>componentDidUpdate</code>：根据渲染前后容器高度，计算一次高度变化量。</li>
<li><code>componentWillUnmount</code>：解除 scroll 事件监听器。</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/icon_man.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/icon_man.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">飞向月球的猫</div><div class="post-copyright__author_desc">个人博客</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://kaiyiya.github.io/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://kaiyiya.github.io/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/')">React进阶实践指南5-理解lifeCycle</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/wx.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wx.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/zfb.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://kaiyiya.github.io/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=React进阶实践指南5-理解lifeCycle&amp;url=http://kaiyiya.github.io/2025/06/16/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3lifeCycle/&amp;pic=https://bu.dusays.com/2025/06/19/685352676eddc.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://kaiyiya.github.io" target="_blank">飞向月球的猫</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>React进阶实践指南<span class="tagsPageCount">10</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2025/06/30/6861d52d81cc2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/06/11/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E8%AE%A4%E8%AF%86Props/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f70a04f5f7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">React进阶实践指南4-认识Props</div></div></a></div><div class="next-post pull-right"><a href="/2025/06/17/%E7%AE%97%E6%B3%95/%E9%9A%BE%E5%BA%A6II/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/685352699da09.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">删除链表的倒数第 N 个结点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/06/19/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E6%8F%90%E4%BE%9B%E8%80%85context/" title="React进阶实践指南7-提供者context"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68537d0c86c49.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-19</div><div class="title">React进阶实践指南7-提供者context</div></div></a></div><div><a href="/2025/06/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E5%AE%9E%E8%B7%B5%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E5%A4%9A%E5%8A%9F%E8%83%BDRef/" title="React实践进阶指南6-多功能Ref"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/6853526848064.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-18</div><div class="title">React实践进阶指南6-多功能Ref</div></div></a></div><div><a href="/2025/06/30/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E6%B8%B2%E6%9F%93%E6%8E%A7%E5%88%B6/" title="React进阶实践指南10-渲染控制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/30/6861d52d53b6e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-30</div><div class="title">React进阶实践指南10-渲染控制</div></div></a></div><div><a href="/2025/06/10/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E8%AE%A4%E8%AF%86Component/" title="React进阶实践指南2-认识ComponentX"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/10/68478ab8d190e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-10</div><div class="title">React进阶实践指南2-认识ComponentX</div></div></a></div><div><a href="/2025/06/30/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E6%A8%A1%E5%9D%97%E5%8C%96css/" title="React进阶实践指南8-模块化css"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68537d0eef6e4.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-30</div><div class="title">React进阶实践指南8-模块化css</div></div></a></div><div><a href="/2025/06/11/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E8%AE%A4%E8%AF%86Props/" title="React进阶实践指南4-认识Props"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f70a04f5f7.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-11</div><div class="title">React进阶实践指南4-认识Props</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/icon_man.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">专注于深度学习、算法、全栈开发、移动端开发、js、python、java、go、c++、c</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">飞向月球的猫</h1><div class="author-info__desc">个人博客</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/kaiyiya" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">一 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">二 类组件生命周期介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%8E%A2%E7%A7%98"><span class="toc-number">2.1.</span> <span class="toc-text">React 类组件生命周期执行过程探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">初始化阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">更新阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.3.</span> <span class="toc-text">销毁阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E5%90%84%E9%98%B6%E6%AE%B5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%83%BD%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.</span> <span class="toc-text">React 各阶段生命周期能做些什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-constructor"><span class="toc-number">2.2.1.</span> <span class="toc-text">1 constructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-getDerivedStateFromProps"><span class="toc-number">2.2.2.</span> <span class="toc-text">2 getDerivedStateFromProps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-componentWillMount-%E5%92%8C-UNSAFE-componentWillMount"><span class="toc-number">2.2.3.</span> <span class="toc-text">3 componentWillMount 和 UNSAFE_componentWillMount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-componentWillReceiveProps-%E5%92%8C-UNSAFE-componentWillReceiveProps"><span class="toc-number">2.2.4.</span> <span class="toc-text">4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-componentWillUpdate-%E5%92%8C-UNSAFE-componentWillUpdate"><span class="toc-number">2.2.5.</span> <span class="toc-text">5 componentWillUpdate 和 UNSAFE_componentWillUpdate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-render"><span class="toc-number">2.2.6.</span> <span class="toc-text">6 render</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-getSnapshotBeforeUpdate"><span class="toc-number">2.2.7.</span> <span class="toc-text">7 getSnapshotBeforeUpdate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-componentDidUpdate"><span class="toc-number">2.2.8.</span> <span class="toc-text">8 componentDidUpdate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-componentDidMount"><span class="toc-number">2.2.9.</span> <span class="toc-text">9 componentDidMount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-shouldComponentUpdate"><span class="toc-number">2.2.10.</span> <span class="toc-text">10 shouldComponentUpdate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-componentWillUnmount"><span class="toc-number">2.2.11.</span> <span class="toc-text">11 componentWillUnmount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.12.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.2.13.</span> <span class="toc-text">生命周期调用顺序说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3React%E5%BC%80%E5%8F%91%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">2.2.14.</span> <span class="toc-text">现代React开发建议：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">3.</span> <span class="toc-text">3 函数组件生命周期替代方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-useEffect-%E5%92%8C-useLayoutEffect"><span class="toc-number">3.1.</span> <span class="toc-text">1 useEffect 和 useLayoutEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-useInsertionEffect"><span class="toc-number">3.2.</span> <span class="toc-text">2 useInsertionEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-componentDidMount-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">3.3.</span> <span class="toc-text">3 componentDidMount 替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-componentWillUnmount-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">3.4.</span> <span class="toc-text">4 componentWillUnmount 替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-componentWillReceiveProps-%E4%BB%A3%E6%9B%BF%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.</span> <span class="toc-text">5 componentWillReceiveProps 代替方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-componentDidUpdate-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">3.6.</span> <span class="toc-text">6 componentDidUpdate 替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%88%E6%9E%9C"><span class="toc-number">3.7.</span> <span class="toc-text">7 完整代码和效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%AE%9E%E8%B7%B5-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAScrollView%E7%BB%84%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">四 实践-实现一个ScrollView组件</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/08/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/ELK/ELK%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2/" title="ELK快速部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/30/6861d52d81cc2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ELK快速部署"/></a><div class="content"><a class="title" href="/2025/07/08/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/ELK/ELK%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2/" title="ELK快速部署">ELK快速部署</a><time datetime="2025-07-08T14:26:30.000Z" title="发表于 2025-07-08 22:26:30">2025-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/06/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JS/JS%E9%87%8D%E9%9A%BE%E7%82%B9%E5%AE%9E%E4%BE%8B%E7%B2%BE%E8%AE%B2/" title="JS重难点实例精讲"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/30/6861d52e11a1b.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS重难点实例精讲"/></a><div class="content"><a class="title" href="/2025/07/06/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JS/JS%E9%87%8D%E9%9A%BE%E7%82%B9%E5%AE%9E%E4%BE%8B%E7%B2%BE%E8%AE%B2/" title="JS重难点实例精讲">JS重难点实例精讲</a><time datetime="2025-07-06T07:31:17.000Z" title="发表于 2025-07-06 15:31:17">2025-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JS/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" title="原型和原型链"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/30/6861d52dafe1c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="原型和原型链"/></a><div class="content"><a class="title" href="/2025/07/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JS/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" title="原型和原型链">原型和原型链</a><time datetime="2025-07-05T07:31:26.000Z" title="发表于 2025-07-05 15:31:26">2025-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/03/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JS/5%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%B9%A0js%E9%87%8D%E9%9A%BE%E7%82%B9/" title="5小时学习js重难点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68537d0f023a9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="5小时学习js重难点"/></a><div class="content"><a class="title" href="/2025/07/03/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JS/5%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%B9%A0js%E9%87%8D%E9%9A%BE%E7%82%B9/" title="5小时学习js重难点">5小时学习js重难点</a><time datetime="2025-07-03T13:58:49.000Z" title="发表于 2025-07-03 21:58:49">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/30/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JS/JS-%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" title="JS-集合引用类型"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/30/6861d52d7bef7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS-集合引用类型"/></a><div class="content"><a class="title" href="/2025/06/30/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JS/JS-%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" title="JS-集合引用类型">JS-集合引用类型</a><time datetime="2025-06-30T08:51:25.000Z" title="发表于 2025-06-30 16:51:25">2025-06-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://user.qzone.qq.com/2194785560/infocenter" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/icon_man.png" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://leetcode.cn/u/zhong-9t9/" title="LeetCode"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-leetcode"></use></svg></a></div><div class="copyright">&copy;2025 By 飞向月球的猫</div><div id="workboard"><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ELK/" style="font-size: 0.88rem;">ELK<sup>1</sup></a><a href="/tags/HAProxy%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/" style="font-size: 0.88rem;">HAProxy负载均衡器<sup>1</sup></a><a href="/tags/JS/" style="font-size: 0.88rem;">JS<sup>4</sup></a><a href="/tags/React%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/" style="font-size: 0.88rem;">React进阶实践指南<sup>10</sup></a><a href="/tags/nodejs%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">nodejs基础<sup>2</sup></a><a href="/tags/%E6%89%8B%E5%86%99linux/" style="font-size: 0.88rem;">手写linux<sup>2</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%88%E9%9A%BE%E5%BA%A6II%EF%BC%89/" style="font-size: 0.88rem;">算法（难度II）<sup>3</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%88%E9%9A%BE%E5%BA%A6I%EF%BC%89/" style="font-size: 0.88rem;">算法（难度I）<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("06/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 飞向月球的猫 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("06/01/2025 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "";
        img.alt = "";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '9cdEFDShTeEeLXIzDivO7iel-gzGzoHsz',
      appKey: 'MrAc9UGI8JwDxY4TJjkOqQ2w',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, ))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://9cdEFDSh.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '9cdEFDShTeEeLXIzDivO7iel-gzGzoHsz',
        "X-LC-Key": 'MrAc9UGI8JwDxY4TJjkOqQ2w',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://at.alicdn.com/t/c/font_4942227_qgbgf4yxr5m.js?spm=a313x.manage_type_myprojects.i1.10.3e7e3a81jTvspY&amp;file=font_4942227_qgbgf4yxr5m.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    const close = () => {
      Chatra('minimizeWidget')
      Chatra('hide')
    }

    const open = () => {
      Chatra('openChat', true)
      Chatra('show')
    }

    window.ChatraSetup = {
      startHidden: true
    }
  
    window.chatBtnFn = () => {
      const isShow = document.getElementById('chatra').classList.contains('chatra--expanded')
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        Chatra('hide')
      },
      show: () => {
        Chatra('show')
      }
    }
  }

  (function(d, w, c) {
    w.ChatraID = 'rBSEkY5Qjp4fmNXzZ'
    var s = d.createElement('script')
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments)
    }
    s.async = true
    s.src = 'https://call.chatra.io/chatra.js'
    if (d.head) d.head.appendChild(s)
  })(document, window, 'Chatra')

})()</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>